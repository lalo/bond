
//------------------------------------------------------------------------------
// This code was generated by a tool.
//
//   Tool : Bond Compiler 0.11.0.0
//   Input filename:  pingpong.bond
//   Output filename: pingpong_grpc.h
//
// Changes to this file may cause incorrect behavior and will be lost when
// the code is regenerated.
// <auto-generated />
//------------------------------------------------------------------------------

#pragma once

#include "pingpong_reflection.h"
#include "pingpong_types.h"

#include <bond/core/bond_reflection.h>
#include <bond/core/bonded.h>
#include <bond/ext/grpc/bond_utils.h>
#include <bond/ext/grpc/client_callback.h>
#include <bond/ext/grpc/io_manager.h>
#include <bond/ext/grpc/reflection.h>
#include <bond/ext/grpc/thread_pool.h>
#include <bond/ext/grpc/unary_call.h>
#include <bond/ext/grpc/detail/client_call_data.h>
#include <bond/ext/grpc/detail/service.h>
#include <bond/ext/grpc/detail/service_call_data.h>

#include <boost/optional/optional.hpp>
#include <forward_list>
#include <functional>
#include <memory>

#ifdef _MSC_VER
#pragma warning (push)
#pragma warning (disable: 4100 4267)
#endif

#include <grpc++/impl/codegen/channel_interface.h>
#include <grpc++/impl/codegen/client_context.h>
#include <grpc++/impl/codegen/completion_queue.h>
#include <grpc++/impl/codegen/rpc_method.h>
#include <grpc++/impl/codegen/status.h>

#ifdef _MSC_VER
#pragma warning (pop)
#endif

namespace Ping
{

class Perf final
{
public:
    struct Schema;

    template <typename TThreadPool>
    class ClientCore
    {
    public:
        ClientCore(
            const std::shared_ptr< ::grpc::ChannelInterface>& channel,
            std::shared_ptr< ::bond::ext::gRPC::io_manager> ioManager,
            std::shared_ptr<TThreadPool> threadPool);

        void AsyncInvoke(::std::shared_ptr< ::grpc::ClientContext> context, const ::bond::bonded< ::Ping::Data>& request, const std::function<void(std::shared_ptr< ::bond::ext::gRPC::unary_call_result< ::Ping::Data>>)>& cb);
        void AsyncInvoke(::std::shared_ptr< ::grpc::ClientContext> context, const ::Ping::Data& request, const std::function<void(std::shared_ptr< ::bond::ext::gRPC::unary_call_result< ::Ping::Data>>)>& cb)
        {
            AsyncInvoke(context, ::bond::bonded< ::Ping::Data>{request}, cb);
        }
        void AsyncInvoke(const ::bond::bonded< ::Ping::Data>& request, const std::function<void(std::shared_ptr< ::bond::ext::gRPC::unary_call_result< ::Ping::Data>>)>& cb)
        {
            AsyncInvoke(::std::make_shared< ::grpc::ClientContext>(), request, cb);
        }
        void AsyncInvoke(const ::Ping::Data& request, const std::function<void(std::shared_ptr< ::bond::ext::gRPC::unary_call_result< ::Ping::Data>>)>& cb)
        {
            AsyncInvoke(::std::make_shared< ::grpc::ClientContext>(), ::bond::bonded< ::Ping::Data>{request}, cb);
        }

        void AsyncKillServer(::std::shared_ptr< ::grpc::ClientContext> context);
        void AsyncKillServer()
        {
            AsyncKillServer(::std::make_shared< ::grpc::ClientContext>());
        }

        ClientCore(const ClientCore&) = delete;
        ClientCore& operator=(const ClientCore&) = delete;

        ClientCore(ClientCore&&) = default;
        ClientCore& operator=(ClientCore&&) = default;

    private:
        std::shared_ptr< ::grpc::ChannelInterface> _channel;
        std::shared_ptr< ::bond::ext::gRPC::io_manager> _ioManager;
        std::shared_ptr<TThreadPool> _threadPool;

        const ::grpc::RpcMethod rpcmethod_Invoke_;

        const ::grpc::RpcMethod rpcmethod_KillServer_;
    };

    using Client = ClientCore< ::bond::ext::gRPC::thread_pool>;

    template <typename TThreadPool>
    class ServiceCore : public ::bond::ext::gRPC::detail::service<TThreadPool>
    {
    public:
        ServiceCore()
        {
            this->AddMethod("/Ping.Perf/Invoke");
            this->AddMethod("/Ping.Perf/KillServer");
        }

        virtual ~ServiceCore() { }
        virtual void start(
            ::grpc::ServerCompletionQueue* cq,
            std::shared_ptr<TThreadPool> tp) override
        {
            BOOST_ASSERT(cq);
            BOOST_ASSERT(tp);

            auto temp = _rd_Invoke.emplace_after(_rd_Invoke.before_begin(), this, 0, cq, tp, [this](::bond::ext::gRPC::unary_call< ::bond::bonded< ::Ping::Data>, ::Ping::Data> call) {this->Invoke(std::move(call));});
            //auto temp2 = _rd_KillServer.emplace(_rd_KillServer.end(), this, 1, cq, tp, ::std::bind(&ServiceCore::KillServer, this, ::std::placeholders::_1));
            //auto temp2 = _rd_KillServer.emplace(_rd_KillServer.end(), this, 1, cq, tp, Bind<bond::Void, bond::Void, &ServiceCore::KillServer>(this));

            this->queue_receive(
                0,
                &temp->_receivedCall->context(),
                &temp->_receivedCall->request(),
                &temp->_receivedCall->responder(),
                cq,
                &*temp);

            /*
            this->queue_receive(
                1,
                &temp2->_receivedCall->context(),
                &temp2->_receivedCall->request(),
                &temp2->_receivedCall->responder(),
                cq,
                &*temp2);
                */

            /*
            _rd_Invoke.emplace(
                this,
                0,
                cq,
                tp,
                std::bind(&ServiceCore::Invoke, this, std::placeholders::_1));
            _rd_KillServer.emplace(
                this,
                1,
                cq,
                tp,
                std::bind(&ServiceCore::KillServer, this, std::placeholders::_1));

            this->queue_receive(
                0,
                &_rd_Invoke->_receivedCall->context(),
                &_rd_Invoke->_receivedCall->request(),
                &_rd_Invoke->_receivedCall->responder(),
                cq,
                &_rd_Invoke.get());
            this->queue_receive(
                1,
                &_rd_KillServer->_receivedCall->context(),
                &_rd_KillServer->_receivedCall->request(),
                &_rd_KillServer->_receivedCall->responder(),
                cq,
                &_rd_KillServer.get());
              */
        }

        virtual void Invoke(::bond::ext::gRPC::unary_call< ::bond::bonded< ::Ping::Data>, ::Ping::Data>) = 0;
        virtual void KillServer(::bond::ext::gRPC::unary_call< ::bond::bonded< ::bond::Void>, ::bond::Void>) = 0;

    private:
        ::std::forward_list< ::bond::ext::gRPC::detail::service_unary_call_data< ::bond::bonded< ::Ping::Data>, ::Ping::Data, TThreadPool>> _rd_Invoke;
        ::std::list< ::bond::ext::gRPC::detail::service_unary_call_data< ::bond::bonded< ::bond::Void>, ::bond::Void, TThreadPool>> _rd_KillServer;
        //::boost::optional< ::bond::ext::gRPC::detail::service_unary_call_data< ::bond::bonded< ::Ping::Data>, ::Ping::Data, TThreadPool>> _rd_Invoke;
        //::boost::optional< ::bond::ext::gRPC::detail::service_unary_call_data< ::bond::bonded< ::bond::Void>, ::bond::Void, TThreadPool>> _rd_KillServer;
    };

    using Service = ServiceCore< ::bond::ext::gRPC::thread_pool>;
};

template <typename TThreadPool>
inline Perf::ClientCore<TThreadPool>::ClientCore(
    const std::shared_ptr< ::grpc::ChannelInterface>& channel,
    std::shared_ptr< ::bond::ext::gRPC::io_manager> ioManager,
    std::shared_ptr<TThreadPool> threadPool)
    : _channel(channel)
    , _ioManager(ioManager)
    , _threadPool(threadPool)
    , rpcmethod_Invoke_("/Ping.Perf/Invoke", ::grpc::RpcMethod::NORMAL_RPC, channel)
    , rpcmethod_KillServer_("/Ping.Perf/KillServer", ::grpc::RpcMethod::NORMAL_RPC, channel)
    { }

template <typename TThreadPool>
inline void Perf::ClientCore<TThreadPool>::AsyncInvoke(
    ::std::shared_ptr< ::grpc::ClientContext> context,
    const ::bond::bonded< ::Ping::Data>& request,
    const std::function<void(std::shared_ptr< ::bond::ext::gRPC::unary_call_result< ::Ping::Data>>)>& cb)
{
    
    auto calldata = std::make_shared< ::bond::ext::gRPC::detail::client_unary_call_data< ::Ping::Data, ::Ping::Data, TThreadPool>>(
        _channel,
        _ioManager,
        _threadPool,
        context,
        cb);
    calldata->dispatch(rpcmethod_Invoke_, request);
}

template <typename TThreadPool>
inline void Perf::ClientCore<TThreadPool>::AsyncKillServer(
    ::std::shared_ptr< ::grpc::ClientContext> context
    )
{
    auto request = ::bond::bonded< ::bond::Void>{ ::bond::Void()};
    auto calldata = std::make_shared< ::bond::ext::gRPC::detail::client_unary_call_data< ::bond::Void, ::bond::Void, TThreadPool>>(
        _channel,
        _ioManager,
        _threadPool,
        context);
    calldata->dispatch(rpcmethod_KillServer_, request);
}

struct Perf::Schema
{
    static const ::bond::Metadata metadata;

    private: static const ::bond::Metadata s_Invoke_metadata;
    private: static const ::bond::Metadata s_KillServer_metadata;

    public: struct service
    {
        typedef ::bond::ext::gRPC::reflection::MethodTemplate<
                Perf,
                ::bond::bonded< ::Ping::Data>,
                ::bond::bonded< ::Ping::Data>,
                &s_Invoke_metadata
            > Invoke;

        typedef ::bond::ext::gRPC::reflection::MethodTemplate<
                Perf,
                ::bond::bonded< ::bond::Void>,
                void,
                &s_KillServer_metadata
            > KillServer;
    };

    private: typedef boost::mpl::list<> methods0;
    private: typedef boost::mpl::push_front<methods0, service::KillServer>::type methods1;
    private: typedef boost::mpl::push_front<methods1, service::Invoke>::type methods2;

    public: typedef methods2::type methods;

    
};



} // namespace Ping

